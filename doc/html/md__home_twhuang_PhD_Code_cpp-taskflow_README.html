<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cpp-Taskflow: Cpp-Taskflow &lt;img align=&quot;right&quot; width=&quot;10%&quot; src=&quot;image/cpp-taskflow_logo.png&quot;&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cpp-Taskflow
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Cpp-Taskflow </p><div class="image">
<img src="image/cpp-taskflow_logo.png" align="right" width="10%"/>
</div>
 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.com/cpp-taskflow/cpp-taskflow"></a> <a href="https://ci.appveyor.com/project/TsungWeiHuang/cpp-taskflow"></a> <a href="https://en.wikipedia.org/wiki/C%2B%2B#Standardization"></a> <a href="https://github.com/cpp-taskflow/cpp-taskflow/archive/master.zip"></a> ./doc/home.md "![Wiki](image/doc-wiki.svg)" <a href="https://github.com/cpp-taskflow/cpp-taskflow/pulse"></a> <a href="./LICENSE"></a></p>
<p>A fast C++ header-only library to help you quickly write parallel programs with complex task dependencies</p>
<h1>Why Cpp-Taskflow?</h1>
<p>Cpp-Taskflow is by far faster, more expressive, fewer lines of code, and easier for drop-in integration than existing parallel task programming libraries such as <a href="http://www.nersc.gov/users/software/programming-models/openmp/openmp-tasking/">OpenMP Tasking</a> and Intel <a href="https://www.threadingbuildingblocks.org/tutorial-intel-tbb-flow-graph">TBB FlowGraph</a>.</p>
<div class="image">
<img src="image/plot/plot.jpg"/>
</div>
<p>Cpp-Taskflow enables you to implement efficient task decomposition strategies that incorporate both regular loop-based parallelism and irregular compute patterns to optimize multicore performance.</p>
<table class="doxtable">
<tr>
<th>Without Cpp-Taskflow </th><th>With Cpp-Taskflow  </th></tr>
<tr>
<td><div class="image">
<img src="image/profile_without_taskflow.gif"/>
</div>
 </td><td><div class="image">
<img src="image/profile_with_taskflow.gif"/>
</div>
 </td></tr>
</table>
<p>Cpp-Taskflow has a unified interface for both <em>static</em> tasking and <em>dynamic</em> tasking, allowing users to quickly master our parallel task programming model in a natural idiom.</p>
<table class="doxtable">
<tr>
<th align="center">Static Tasking </th><th align="center">Dynamic Tasking  </th></tr>
<tr>
<td align="center"><div class="image">
<img src="image/static_graph.png"/>
</div>
 </td><td align="center"><div class="image">
<img src="image/dynamic_graph.png"/>
</div>
 </td></tr>
</table>
<p>Cpp-Taskflow is committed to support both academic and industry research projects, making it reliable and cost-effective for long-term and large-scale developments.</p>
<ul>
<li>*"Cpp-Taskflow is the cleanest Task API I've ever seen." <a href="https://github.com/damienhocking">damienhocking</a>*</li>
<li>*"Cpp-Taskflow has a very simple and elegant tasking interface. The performance also scales very well." <a href="https://github.com/totalgee">totalgee</a>*</li>
<li>*"Best poster award for open-source parallel programming library." <a href="https://github.com/CppCon/CppCon2018">Cpp Conference 2018</a>*</li>
</ul>
<p>See a quick <a href="https://cpp-taskflow.github.io/">presentation</a> and visit the ./doc/home.md "documentation" to learn more about Cpp-Taskflow.</p>
<h1>Get Started with Cpp-Taskflow</h1>
<p>The following example <a href="./example/simple.cpp">simple.cpp</a> shows the basic Cpp-Taskflow API you need in most applications.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="taskflow_8hpp.html">taskflow/taskflow.hpp</a>&gt;</span>  <span class="comment">// Cpp-Taskflow is header-only</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line"></div><div class="line">  <a class="code" href="classtf_1_1BasicTaskflow.html">tf::Taskflow</a> <a class="code" href="namespacetf.html">tf</a>;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> [A, B, C, D] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>(</div><div class="line">    [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;TaskA\n&quot;</span>; },               <span class="comment">//  task dependency graph</span></div><div class="line">    [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;TaskB\n&quot;</span>; },               <span class="comment">// </span></div><div class="line">    [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;TaskC\n&quot;</span>; },               <span class="comment">//          +---+          </span></div><div class="line">    [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;TaskD\n&quot;</span>; }                <span class="comment">//    +----&gt;| B |-----+   </span></div><div class="line">  );                                                 <span class="comment">//    |     +---+     |</span></div><div class="line">                                                     <span class="comment">//  +---+           +-v-+ </span></div><div class="line">  A.precede(B);  <span class="comment">// A runs before B                  //  | A |           | D | </span></div><div class="line">  A.precede(C);  <span class="comment">// A runs before C                  //  +---+           +-^-+ </span></div><div class="line">  B.precede(D);  <span class="comment">// B runs before D                  //    |     +---+     |    </span></div><div class="line">  C.precede(D);  <span class="comment">// C runs before D                  //    +----&gt;| C |-----+    </span></div><div class="line">                                                     <span class="comment">//          +---+          </span></div><div class="line">  tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a37ef86998f23ee7315be032c40fe815e">wait_for_all</a>();  <span class="comment">// block until finish</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Compile and run the code with the following commands:</p>
<div class="fragment"><div class="line">~$ g++ simple.cpp -std=c++1z -O2 -lpthread -o simple</div><div class="line">~$ ./simple</div><div class="line">TaskA</div><div class="line">TaskC  &lt;-- concurrent with TaskB</div><div class="line">TaskB  &lt;-- concurrent with TaskC</div><div class="line">TaskD</div></div><!-- fragment --><p>It is clear now Cpp-Taskflow is powerful in parallelizing tasks with complex dependencies. The following example demonstrates a concurrent execution of 10 tasks with 15 dependencies. With Cpp-Taskflow, you only need <em><b>15 lines of code</b></em>.</p>
<div class="image">
<img src="image/complex.png" align="right" width="30%"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// source dependencies</span></div><div class="line">S.precede(a0);    <span class="comment">// S runs before a0</span></div><div class="line">S.precede(b0);    <span class="comment">// S runs before b0</span></div><div class="line">S.precede(a1);    <span class="comment">// S runs before a1</span></div><div class="line"></div><div class="line"><span class="comment">// a_ -&gt; others</span></div><div class="line">a0.precede(a1);   <span class="comment">// a0 runs before a1</span></div><div class="line">a0.precede(b2);   <span class="comment">// a0 runs before b2</span></div><div class="line">a1.precede(a2);   <span class="comment">// a1 runs before a2</span></div><div class="line">a1.precede(b3);   <span class="comment">// a1 runs before b3</span></div><div class="line">a2.precede(a3);   <span class="comment">// a2 runs before a3</span></div><div class="line"></div><div class="line"><span class="comment">// b_ -&gt; others</span></div><div class="line">b0.precede(b1);   <span class="comment">// b0 runs before b1</span></div><div class="line">b1.precede(b2);   <span class="comment">// b1 runs before b2</span></div><div class="line">b2.precede(b3);   <span class="comment">// b2 runs before b3</span></div><div class="line">b2.precede(a3);   <span class="comment">// b2 runs before a3</span></div><div class="line"></div><div class="line"><span class="comment">// target dependencies</span></div><div class="line">a3.precede(T);    <span class="comment">// a3 runs before T</span></div><div class="line">b1.precede(T);    <span class="comment">// b1 runs before T</span></div><div class="line">b3.precede(T);    <span class="comment">// b3 runs before T</span></div></div><!-- fragment --><h1>Create a Taskflow Graph</h1>
<p>Cpp-Taskflow has very expressive and neat methods to create dependency graphs. Most applications are developed through the following three steps.</p>
<h2>Step 1: Create a Task</h2>
<p>A task is a callable object for which <a href="https://en.cppreference.com/w/cpp/utility/functional/invoke">std::invoke</a> is applicable. Create a taskflow object to start a task dependency graph.</p>
<div class="fragment"><div class="line"><a class="code" href="classtf_1_1BasicTaskflow.html">tf::Taskflow</a> tf;</div></div><!-- fragment --><p>Create a task from a callable object via the method <code>silent_emplace</code> to get a task handle.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([](){ std::cout &lt;&lt; <span class="stringliteral">&quot;Task A\n&quot;</span>; });</div></div><!-- fragment --><p>You can create multiple tasks at one time.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [A, B, C, D] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>(</div><div class="line">  [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;Task A\n&quot;</span>; },</div><div class="line">  [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;Task B\n&quot;</span>; },</div><div class="line">  [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;Task C\n&quot;</span>; },</div><div class="line">  [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;Task D\n&quot;</span>; }</div><div class="line">);</div></div><!-- fragment --><h2>Step 2: Define Task Dependencies</h2>
<p>Once tasks are created in the pool, you need to specify task dependencies in a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph (DAG)</a> fashion. The handle <code>Task</code> supports different methods for you to describe task dependencies.</p>
<p><b>Precede</b>: Adding a preceding link forces one task to run ahead of one another. </p><div class="fragment"><div class="line">A.precede(B);  <span class="comment">// A runs before B.</span></div></div><!-- fragment --><p><b>Gather</b>: Adding a gathering link forces one task to run after other(s). </p><div class="fragment"><div class="line">A.gather(B);  <span class="comment">// A runs after B</span></div></div><!-- fragment --><h2>Step 3: Execute the Tasks</h2>
<p>There are three methods to execute a task dependency graph, <code>dispatch</code>, <code>silent_dispatch</code>, and <code>wait_for_all</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> future = tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a848e425f67b49a8a7ac21f6b791999c5">dispatch</a>();  <span class="comment">// non-blocking, returns with a future immediately.</span></div><div class="line">tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a0126001a2bd8603af4827049578629cb">silent_dispatch</a>();         <span class="comment">// non-blocking, no return</span></div></div><!-- fragment --><p>Calling <code>wait_for_all</code> will block until all tasks complete.</p>
<div class="fragment"><div class="line">tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a37ef86998f23ee7315be032c40fe815e">wait_for_all</a>();</div></div><!-- fragment --><p>Each of these methods dispatches the current graph to threads for execution and create a data structure called <em>topology</em> to store the execution status.</p>
<h1>Dynamic Tasking</h1>
<p>Another powerful feature of Taskflow is <em>dynamic</em> tasking. A dynamic task is created during the execution of a dispatched taskflow graph, i.e., topology. These tasks are spawned by a parent task and are grouped together to a <em>subflow</em> graph. The example below demonstrates how to create a subflow that spawns three tasks during its execution.</p>
<div class="image">
<img src="image/subflow_join.png" align="right" width="40%"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// create three regular tasks</span></div><div class="line"><span class="keyword">auto</span> A = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([](){}).name(<span class="stringliteral">&quot;A&quot;</span>);</div><div class="line"><span class="keyword">auto</span> C = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([](){}).name(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line"><span class="keyword">auto</span> D = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([](){}).name(<span class="stringliteral">&quot;D&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// create a subflow graph (dynamic tasking)</span></div><div class="line"><span class="keyword">auto</span> B = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] (<span class="keyword">auto</span>&amp; subflow) {</div><div class="line">  <span class="keyword">auto</span> B1 = subflow.silent_emplace([](){}).name(<span class="stringliteral">&quot;B1&quot;</span>);</div><div class="line">  <span class="keyword">auto</span> B2 = subflow.silent_emplace([](){}).name(<span class="stringliteral">&quot;B2&quot;</span>);</div><div class="line">  <span class="keyword">auto</span> B3 = subflow.silent_emplace([](){}).name(<span class="stringliteral">&quot;B3&quot;</span>);</div><div class="line">  B1.precede(B3);</div><div class="line">  B2.precede(B3);</div><div class="line">}).name(<span class="stringliteral">&quot;B&quot;</span>);</div><div class="line"></div><div class="line">A.precede(B);  <span class="comment">// B runs after A </span></div><div class="line">A.precede(C);  <span class="comment">// C runs after A </span></div><div class="line">B.precede(D);  <span class="comment">// D runs after B </span></div><div class="line">C.precede(D);  <span class="comment">// D runs after C </span></div><div class="line"></div><div class="line"><span class="comment">// execute the graph without cleanning up topologies</span></div><div class="line">tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a848e425f67b49a8a7ac21f6b791999c5">dispatch</a>().get();</div><div class="line">std::cout &lt;&lt; tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a6ada71950f0e3384f2ab95814bbc7c3f">dump_topologies</a>();</div></div><!-- fragment --><p>By default, a subflow graph joins to its parent node. This guarantees a subflow graph to finish before the successors of its parent node. You can disable this feature by calling <code>subflow.detach()</code>. Detaching the above subflow will result in the following execution flow.</p>
<div class="image">
<img src="image/subflow_detach.png" align="right" width="65%"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// detach a subflow graph</span></div><div class="line">[] (<span class="keyword">auto</span>&amp; subflow) {</div><div class="line">  ...</div><div class="line">  B1.precede(B3);</div><div class="line">  B2.precede(B3);</div><div class="line"></div><div class="line">  <span class="comment">// detach from B </span></div><div class="line">  subflow.detach();</div><div class="line">}).name(<span class="stringliteral">&quot;TaskB&quot;</span>);</div></div><!-- fragment --><h2>Step 1: Create a Subflow</h2>
<p>Cpp-Taskflow has an unified interface for static and dynamic tasking. To create a subflow for dynamic tasking, emplace a callable on one argument of type <code><a class="el" href="classtf_1_1SubflowBuilder.html">tf::SubflowBuilder</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] (<a class="code" href="classtf_1_1SubflowBuilder.html">tf::SubflowBuilder</a>&amp; subflow) {});</div></div><!-- fragment --><p>Similarly, you can get a <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> object to the execution status of the subflow.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [A, fu] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a6d9c6008100d099994362769d1ea7fbb">emplace</a>([] (<a class="code" href="classtf_1_1SubflowBuilder.html">tf::SubflowBuilder</a>&amp; subflow) {});</div></div><!-- fragment --><p>A subflow builder is a lightweight object that allows you to create arbitrary dependency graphs on the fly. All graph building methods defined in taskflow can be used in a subflow builder.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] (<a class="code" href="classtf_1_1SubflowBuilder.html">tf::SubflowBuilder</a>&amp; subflow) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Task A is spawning two subtasks A1 and A2&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  <span class="keyword">auto</span> [A1, A2] = subflow.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>(</div><div class="line">    [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;subtask A1&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; },</div><div class="line">    [] () { std::cout &lt;&lt; <span class="stringliteral">&quot;subtask A2&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; }</div><div class="line">    A1.precede(A2);</div><div class="line">  );</div><div class="line">});</div></div><!-- fragment --><p>A subflow can also be nested or recursive. You can create another subflow from the execution of a subflow and so on.</p>
<div class="image">
<img src="image/nested_subflow.png" align="right" width="45%"/>
</div>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] (<span class="keyword">auto</span>&amp; sbf){</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;A spawns A1 &amp; subflow A2\n&quot;</span>;</div><div class="line">  <span class="keyword">auto</span> A1 = sbf.silent_emplace([] () { </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;subtask A1\n&quot;</span>; </div><div class="line">  }).name(<span class="stringliteral">&quot;A1&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> A2 = sbf.silent_emplace([] (<span class="keyword">auto</span>&amp; sbf2){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;A2 spawns A2_1 &amp; A2_2\n&quot;</span>;</div><div class="line">    <span class="keyword">auto</span> A2_1 = sbf2.silent_emplace([] () { </div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;subtask A2_1\n&quot;</span>; </div><div class="line">    }).name(<span class="stringliteral">&quot;A2_1&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> A2_2 = sbf2.silent_emplace([] () { </div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;subtask A2_2\n&quot;</span>; </div><div class="line">    }).name(<span class="stringliteral">&quot;A2_2&quot;</span>);</div><div class="line">    A2_1.precede(A2_2);</div><div class="line">  }).name(<span class="stringliteral">&quot;A2&quot;</span>);</div><div class="line">  A1.precede(A2);</div><div class="line">}).name(<span class="stringliteral">&quot;A&quot;</span>);</div></div><!-- fragment --><h2>Step 2: Detach or Join a Subflow</h2>
<p>A subflow has no methods to dispatch its tasks. Instead, a subflow will be executed after leaving the context of the callable. By default, a subflow joins to its parent task. Depending on applications, you can detach a subflow to enable more parallelism.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> A = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] (<a class="code" href="classtf_1_1SubflowBuilder.html">tf::SubflowBuilder</a>&amp; subflow) {</div><div class="line">  subflow.<a class="code" href="classtf_1_1SubflowBuilder.html#a0660bc0ca5ec375700703cbc94f66942">detach</a>();  <span class="comment">// detach this subflow from its parent task A</span></div><div class="line">});  <span class="comment">// subflow starts to run after the callable scope</span></div></div><!-- fragment --><p>Detaching or Joining a subflow has different meaning in the ready status of the future object referred to it. In a joined subflow, the completion of its parent node is defined as when all tasks inside the subflow (possibly nested) finish.</p>
<div class="image">
<img src="image/joined_subflow_future.png" align="right" width="40%"/>
</div>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> value {0};</div><div class="line"></div><div class="line"><span class="comment">// create a joined subflow</span></div><div class="line"><span class="keyword">auto</span> [A, fuA] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a6d9c6008100d099994362769d1ea7fbb">emplace</a>([&amp;] (<span class="keyword">auto</span>&amp; subflow) {</div><div class="line">  subflow.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([&amp;]() { </div><div class="line">    value = 10; </div><div class="line">  });</div><div class="line">  <span class="keywordflow">return</span> 100;   <span class="comment">// some arbitrary value</span></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// create a task B after A</span></div><div class="line"><span class="keyword">auto</span> B = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([&amp;] () { </div><div class="line">  assert(value == 10); </div><div class="line">  assert(fuA.wait_for(0s) == std::future_status::ready);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// A1 must finish before A and therefore before B</span></div><div class="line">A.precede(B);</div></div><!-- fragment --><p>When a subflow is detached from its parent task, it becomes a parallel execution line to the current flow graph and will eventually join to the same topology.</p>
<div class="image">
<img src="image/detached_subflow_future.png" align="right" width="40%"/>
</div>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> value {0};</div><div class="line"></div><div class="line"><span class="comment">// create a detached subflow</span></div><div class="line"><span class="keyword">auto</span> [A, fuA] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a6d9c6008100d099994362769d1ea7fbb">emplace</a>([&amp;] (<span class="keyword">auto</span>&amp; subflow) {</div><div class="line">  subflow.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([&amp;]() { value = 10; });</div><div class="line">  subflow.<a class="code" href="classtf_1_1SubflowBuilder.html#a0660bc0ca5ec375700703cbc94f66942">detach</a>();</div><div class="line">  <span class="keywordflow">return</span> 100;   <span class="comment">// some arbitrary value</span></div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// create a task B after A</span></div><div class="line"><span class="keyword">auto</span> B = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([&amp;] () { </div><div class="line">  <span class="comment">// no guarantee for value to be 10 nor fuA ready</span></div><div class="line">});</div><div class="line">A.precede(B);</div></div><!-- fragment --><h1>Debug a Taskflow Graph</h1>
<p>Concurrent programs are notoriously difficult to debug. Cpp-Taskflow leverages the graph properties to relieve the debugging pain. To debug a taskflow graph, (1) name tasks and dump the graph, and (2) start with one thread before going multiple. Currently, Cpp-Taskflow supports <a href="https://www.graphviz.org/">GraphViz</a> format.</p>
<h2>Dump the Present Taskflow Graph</h2>
<p>Each time you create a task or add a dependency, it adds a node or an edge to the present taskflow graph. The graph is not dispatched yet and you can dump it to a GraphViz format.</p>
<div class="fragment"><div class="line"><span class="comment">// debug.cpp</span></div><div class="line"><a class="code" href="classtf_1_1BasicTaskflow.html">tf::Taskflow</a> tf(0);  <span class="comment">// use only the master thread</span></div><div class="line"><span class="keyword">auto</span> A = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] () {}).name(<span class="stringliteral">&quot;A&quot;</span>);</div><div class="line"><span class="keyword">auto</span> B = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] () {}).name(<span class="stringliteral">&quot;B&quot;</span>);</div><div class="line"><span class="keyword">auto</span> C = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] () {}).name(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line"><span class="keyword">auto</span> D = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] () {}).name(<span class="stringliteral">&quot;D&quot;</span>);</div><div class="line"><span class="keyword">auto</span> E = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] () {}).name(<span class="stringliteral">&quot;E&quot;</span>);</div><div class="line"></div><div class="line">A.broadcast(B, C, E); </div><div class="line">C.precede(D);</div><div class="line">B.broadcast(D, E); </div><div class="line"></div><div class="line">std::cout &lt;&lt; tf.<a class="code" href="classtf_1_1BasicTaskflow.html#aec75723fc4f48197bc92748ed8b12d2a">dump</a>();</div></div><!-- fragment --><p>Run the program and inspect whether dependencies are expressed in the right way. There are a number of free <a href="https://github.com/CodeFreezr/awesome-graphviz">GraphViz tools</a> you could find online to visualize your Taskflow graph.</p>
<div class="image">
<img src="image/graphviz.png" align="right" width="25%"/>
</div>
<div class="fragment"><div class="line">~$ ./debug</div><div class="line"></div><div class="line">// Taskflow with five tasks and six dependencies</div><div class="line">digraph Taskflow {</div><div class="line">  &quot;A&quot; -&gt; &quot;B&quot;</div><div class="line">  &quot;A&quot; -&gt; &quot;C&quot;</div><div class="line">  &quot;A&quot; -&gt; &quot;E&quot;</div><div class="line">  &quot;B&quot; -&gt; &quot;D&quot;</div><div class="line">  &quot;B&quot; -&gt; &quot;E&quot;</div><div class="line">  &quot;C&quot; -&gt; &quot;D&quot;</div><div class="line">}</div></div><!-- fragment --><h2>Dump the Dispatched Graphs</h2>
<p>When you have dynamic tasks (subflows), you cannot simply use the <code>dump</code> method because it displays only the static portion. Instead, you need to execute the graph first to include dynamic tasks and then use the <code>dump_topologies</code> method.</p>
<div class="image">
<img src="image/debug_subflow.png" align="right" width="40%"/>
</div>
<div class="fragment"><div class="line"><a class="code" href="classtf_1_1BasicTaskflow.html">tf::Taskflow</a> tf(0);  <span class="comment">// use only the master thread</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> A = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([](){}).name(<span class="stringliteral">&quot;A&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// create a subflow of two tasks B1-&gt;B2</span></div><div class="line"><span class="keyword">auto</span> B = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([] (<span class="keyword">auto</span>&amp; subflow) {</div><div class="line">  <span class="keyword">auto</span> B1 = subflow.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([](){}).name(<span class="stringliteral">&quot;B1&quot;</span>);</div><div class="line">  <span class="keyword">auto</span> B2 = subflow.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([](){}).name(<span class="stringliteral">&quot;B2&quot;</span>);</div><div class="line">  B1.precede(B2);</div><div class="line">}).name(<span class="stringliteral">&quot;B&quot;</span>);</div><div class="line"></div><div class="line">A.precede(B);</div><div class="line"></div><div class="line"><span class="comment">// dispatch the graph without cleanning up topologies</span></div><div class="line">tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a848e425f67b49a8a7ac21f6b791999c5">dispatch</a>().get();</div><div class="line"></div><div class="line"><span class="comment">// dump the entire graph (including dynamic tasks)</span></div><div class="line">std::cout &lt;&lt; tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a6ada71950f0e3384f2ab95814bbc7c3f">dump_topologies</a>();</div></div><!-- fragment --><h1>API Reference</h1>
<h2>Taskflow API</h2>
<p>The class <code><a class="el" href="namespacetf.html#aa4b65604639a98fffa65678506be94c9">tf::Taskflow</a></code> is the main place to create and execute task dependency graph. The table below summarizes a list of commonly used methods. Visit ./doc/home.md "documentation" to see the complete list.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Argument </th><th>Return </th><th>Description  </th></tr>
<tr>
<td>Taskflow </td><td>none </td><td>none </td><td>construct a taskflow with the worker count equal to max hardware concurrency </td></tr>
<tr>
<td>Taskflow </td><td>size </td><td>none </td><td>construct a taskflow with a given number of workers </td></tr>
<tr>
<td>emplace </td><td>callables </td><td>tasks, futures </td><td>insert nodes to execute the given callables; results can be retrieved from the returned futures </td></tr>
<tr>
<td>silent_emplace </td><td>callables </td><td>tasks </td><td>insert nodes to execute the given callables </td></tr>
<tr>
<td>placeholder </td><td>none </td><td>task </td><td>insert a node without any work; work can be assigned later </td></tr>
<tr>
<td>linearize </td><td>task list </td><td>none </td><td>create a linear dependency in the given task list </td></tr>
<tr>
<td>parallel_for </td><td>beg, end, callable, group </td><td>task pair </td><td>apply the callable in parallel and group-by-group to the result of dereferencing every iterator in the range </td></tr>
<tr>
<td>parallel_for </td><td>beg, end, step, callable, group </td><td>task pair </td><td>apply the callable in parallel and group-by-group to a index-based range </td></tr>
<tr>
<td>reduce </td><td>beg, end, res, bop </td><td>task pair </td><td>reduce a range of elements to a single result through a binary operator </td></tr>
<tr>
<td>transform_reduce </td><td>beg, end, res, bop, uop </td><td>task pair </td><td>apply a unary operator to each element in the range and reduce them to a single result through a binary operator </td></tr>
<tr>
<td>dispatch </td><td>none </td><td>future </td><td>dispatch the current graph and return a shared future to block on completion </td></tr>
<tr>
<td>silent_dispatch </td><td>none </td><td>none </td><td>dispatch the current graph </td></tr>
<tr>
<td>wait_for_all </td><td>none </td><td>none </td><td>dispatch the current graph and block until all graphs finish, including all previously dispatched ones, and then clear all graphs </td></tr>
<tr>
<td>wait_for_topologies </td><td>none </td><td>none </td><td>block until all dispatched graphs (topologies) finish, and then clear these graphs </td></tr>
<tr>
<td>num_nodes </td><td>none </td><td>size </td><td>return the number of nodes in the current graph </td></tr>
<tr>
<td>num_workers </td><td>size </td><td>none </td><td>set the number of worker threads in the pool </td></tr>
<tr>
<td>num_workers </td><td>none </td><td>size </td><td>return the number of working threads in the pool </td></tr>
<tr>
<td>num_topologies </td><td>none </td><td>size </td><td>return the number of dispatched graphs </td></tr>
<tr>
<td>dump </td><td>none </td><td>string </td><td>dump the current graph to a string of GraphViz format </td></tr>
<tr>
<td>dump_topologies </td><td>none </td><td>string </td><td>dump dispatched topologies to a string of GraphViz format </td></tr>
</table>
<h3>*emplace/silent_emplace/placeholder*</h3>
<p>The main different between <code>emplace</code> and <code>silent_emplace</code> is the return value. The method <code>emplace</code> gives you a <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> object to retrieve the result of the callable when the task completes.</p>
<div class="fragment"><div class="line"><span class="comment">// create a task through emplace</span></div><div class="line"><span class="keyword">auto</span> [task, future] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a6d9c6008100d099994362769d1ea7fbb">emplace</a>([](){ <span class="keywordflow">return</span> 1; });</div><div class="line">tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a37ef86998f23ee7315be032c40fe815e">wait_for_all</a>();</div><div class="line">assert(future.get() == 1);</div></div><!-- fragment --><p>If you don't care the return result, using <code>silent_emplace</code> to create a task can give you slightly better performance. </p><div class="fragment"><div class="line"><span class="comment">// create a task through silent_emplace</span></div><div class="line"><span class="keyword">auto</span> task = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a6d9c6008100d099994362769d1ea7fbb">emplace</a>([](){ <span class="keywordflow">return</span>; });</div><div class="line">tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a37ef86998f23ee7315be032c40fe815e">wait_for_all</a>();</div></div><!-- fragment --><p>When task cannot be determined beforehand, you can create a placeholder and assign the calalble later. </p><div class="fragment"><div class="line"><span class="comment">// create a placeholder and use it to build dependency</span></div><div class="line"><span class="keyword">auto</span> A = tf.<a class="code" href="classtf_1_1FlowBuilder.html#af8cdada0684ce221c4c134e1504cabd6">silent_emplace</a>([](){});</div><div class="line"><span class="keyword">auto</span> B = tf.<a class="code" href="classtf_1_1FlowBuilder.html#ac22f244fb2ec58809192faafa266c58c">placeholder</a>();</div><div class="line">A.precede(B);</div><div class="line"></div><div class="line"><span class="comment">// assign the callable later in the control flow</span></div><div class="line">B.work([](){ <span class="comment">/* do something */</span> });</div></div><!-- fragment --><h3>*linearize*</h3>
<p>The method <code>linearize</code> lets you add a linear dependency between each adjacent pair of a task sequence.</p>
<div class="image">
<img src="image/linearize.png" align="right" width="40%"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// linearize five tasks</span></div><div class="line">tf.<a class="code" href="classtf_1_1FlowBuilder.html#a830e6242588432bac68c4430ae5912f6">linearize</a>(A, B, C, D);</div></div><!-- fragment --><h3>*parallel_for*</h3>
<p>The method <code>parallel_for</code> creates a subgraph that applies the callable to each item in the given range of a container.</p>
<div class="image">
<img src="image/parallel_for.png" align="right" width="40%"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// apply callable to each container item in parallel</span></div><div class="line"><span class="keyword">auto</span> v = {<span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;B&#39;</span>, <span class="charliteral">&#39;C&#39;</span>, <span class="charliteral">&#39;D&#39;</span>};</div><div class="line"><span class="keyword">auto</span> [S, T] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a016f6bb3fd6719eda5211c7befab3830">parallel_for</a>(</div><div class="line">  v.begin(),    <span class="comment">// beg of range</span></div><div class="line">  v.end(),      <span class="comment">// end of range</span></div><div class="line">  [] (<span class="keywordtype">int</span> i) { </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;parallel in &quot;</span> &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  }</div><div class="line">);</div><div class="line"><span class="comment">// add dependencies via S and T.</span></div></div><!-- fragment --><p>Changing the group size can force intra-group tasks to run sequentially and inter-group tasks to run in parallel. Depending on applications, different group sizes can result in significant performance hit.</p>
<div class="image">
<img src="image/parallel_for_2.png" align="right" width="20%"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// apply callable to two container items at a time in parallel</span></div><div class="line"><span class="keyword">auto</span> v = {<span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;B&#39;</span>, <span class="charliteral">&#39;C&#39;</span>, <span class="charliteral">&#39;D&#39;</span>};</div><div class="line"><span class="keyword">auto</span> [S, T] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a016f6bb3fd6719eda5211c7befab3830">parallel_for</a>(</div><div class="line">  v.begin(),    <span class="comment">// beg of range</span></div><div class="line">  v.end(),      <span class="comment">// end of range</span></div><div class="line">  [] (<span class="keywordtype">int</span> i) { </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;AB and CD run in parallel&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">  },</div><div class="line">  2  <span class="comment">// group two tasks at a time</span></div><div class="line">);</div></div><!-- fragment --><p>By default, taskflow performs an even partition over worker threads if the group size is not specified (or equal to 0).</p>
<p>In addition to range-based iterator, parallel_for has another overload on an index-based loop. The first three argument to this overload indicates starting index, ending index (exclusive), and step size.</p>
<div class="fragment"><div class="line"><span class="comment">// [0, 10) with a step size of 2</span></div><div class="line"><span class="keyword">auto</span> [S, T] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a016f6bb3fd6719eda5211c7befab3830">parallel_for</a>(</div><div class="line">  0, 10, 2, </div><div class="line">  [] (<span class="keywordtype">int</span> i) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;parallel_for on index &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">  }, </div><div class="line">  2  <span class="comment">// group two tasks at a time</span></div><div class="line">);</div><div class="line"><span class="comment">// will print 0, 2, 4, 6, 8 (three groups, {0, 2}, {4, 6}, {8})</span></div></div><!-- fragment --><p>You can also go opposite direction by reversing the starting index and the ending index with a negative step size.</p>
<div class="fragment"><div class="line"><span class="comment">// [10, 0) with a step size of -2</span></div><div class="line"><span class="keyword">auto</span> [S, T] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a016f6bb3fd6719eda5211c7befab3830">parallel_for</a>(</div><div class="line">  10, 0, 2, </div><div class="line">  [] (<span class="keywordtype">int</span> i) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;parallel_for on index &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">);</div><div class="line"><span class="comment">// will print 10, 8, 6, 4, 2 (group size decided by taskflow)</span></div></div><!-- fragment --><h3>*reduce/transform_reduce*</h3>
<p>The method <code>reduce</code> creates a subgraph that applies a binary operator to a range of items. The result will be stored in the referenced <code>res</code> object passed to the method. It is your responsibility to assign it a correct initial value to reduce.</p>
<div class="image">
<img src="image/reduce.png" align="right" width="45%"/>
</div>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = {1, 2, 3, 4}; </div><div class="line"><span class="keywordtype">int</span> sum {0};</div><div class="line"><span class="keyword">auto</span> [S, T] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#a977deae532c85dca046658a0048daa8e">reduce</a>(    <span class="comment">// for example, 2 threads</span></div><div class="line">  v.begin(), v.end(), sum, std::plus&lt;int&gt;()</div><div class="line">);  </div></div><!-- fragment --><p>The method <code>transform_reduce</code> is similar to reduce, except it applies a unary operator before reduction. This is particular useful when you need additional data processing to reduce a range of elements.</p>
<div class="fragment"><div class="line">std::vector&lt;std::pari&lt;int, int&gt;&gt; v = { {1, 5}, {6, 4}, {-6, 4} };</div><div class="line"><span class="keywordtype">int</span> min = std::numeric_limits&lt;int&gt;::max();</div><div class="line"><span class="keyword">auto</span> [S, T] = tf.<a class="code" href="classtf_1_1FlowBuilder.html#ac4d38ee88ae922d3cb8c9808c418764f">transform_reduce</a>(v.begin(), v.end(), min, </div><div class="line">  [] (<span class="keywordtype">int</span> l, <span class="keywordtype">int</span> r) { <span class="keywordflow">return</span> std::min(l, r); },</div><div class="line">  [] (<span class="keyword">const</span> std::pair&lt;int, int&gt;&amp; pair) { <span class="keywordflow">return</span> std::min(p.first, p.second); }</div><div class="line">);</div></div><!-- fragment --><p>By default, all reduce methods distribute the workload evenly across threads.</p>
<h3>*dispatch/silent_dispatch/wait_for_topologies/wait_for_all*</h3>
<p>Dispatching a taskflow graph will schedule threads to execute the current graph and return immediately. The method <code>dispatch</code> gives you a <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> object to probe the execution progress while <code>silent_dispatch</code> doesn't.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> future = tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a848e425f67b49a8a7ac21f6b791999c5">dispatch</a>();</div><div class="line"><span class="comment">// do something else to overlap with the execution </span></div><div class="line"><span class="comment">// ...</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;now I need to block on completion&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">future.get();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;all tasks complete&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div></div><!-- fragment --><p>If you need to block your program flow until all tasks finish (including the present taskflow graph), use <code>wait_for_all</code> instead.</p>
<div class="fragment"><div class="line">tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a37ef86998f23ee7315be032c40fe815e">wait_for_all</a>();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;all tasks complete&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div></div><!-- fragment --><p>If you only need to block your program flow until all dispatched taskflow graphs finish, use <code>wait_for_topologies</code>.</p>
<div class="fragment"><div class="line">tf.<a class="code" href="classtf_1_1BasicTaskflow.html#a8f0ce2026118e97b83cbd727ed0932af">wait_for_topologies</a>();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;all topologies complete&quot;</span> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div></div><!-- fragment --><h2>Task API</h2>
<p>Each time you create a task, the taskflow object adds a node to the present task dependency graph and return a <em>task handle</em> to you. A task handle is a lightweight object that defines a set of methods for users to access and modify the attributes of the associated task. The table below summarizes the list of commonly used methods. Visit ./doc/home.md "documentation" to see the complete list.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Argument </th><th>Return </th><th>Description  </th></tr>
<tr>
<td>name </td><td>string </td><td>self </td><td>assign a human-readable name to the task </td></tr>
<tr>
<td>work </td><td>callable </td><td>self </td><td>assign a work of a callable object to the task </td></tr>
<tr>
<td>precede </td><td>task </td><td>self </td><td>enable this task to run <em>before</em> the given task </td></tr>
<tr>
<td>broadcast </td><td>task list </td><td>self </td><td>enable this task to run <em>before</em> the given tasks </td></tr>
<tr>
<td>gather </td><td>task list </td><td>self </td><td>enable this task to run <em>after</em> the given tasks </td></tr>
<tr>
<td>num_dependents </td><td>none </td><td>size </td><td>return the number of dependents (inputs) of this task </td></tr>
<tr>
<td>num_successors </td><td>none </td><td>size </td><td>return the number of successors (outputs) of this task </td></tr>
</table>
<h3>*name*</h3>
<p>The method <code>name</code> lets you assign a human-readable string to a task.</p>
<div class="fragment"><div class="line">A.name(<span class="stringliteral">&quot;my name is A&quot;</span>);</div></div><!-- fragment --><h3>*work*</h3>
<p>The method <code>work</code> lets you assign a callable to a task.</p>
<div class="fragment"><div class="line">A.work([] () { std::cout &lt;&lt; <span class="stringliteral">&quot;hello world!&quot;</span>; });</div></div><!-- fragment --><h3>*precede*</h3>
<p>The method <code>precede</code> is the basic building block to add a precedence between two tasks.</p>
<div class="image">
<img src="image/precede.png" align="right" width="20%"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// make A runs before B</span></div><div class="line">A.precede(B);</div></div><!-- fragment --><h3>*broadcast*</h3>
<p>The method <code>broadcast</code> lets you precede a task to multiple tasks.</p>
<div class="image">
<img src="image/broadcast.png" align="right" width="30%"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// make A run before B, C, D, and E</span></div><div class="line"><span class="comment">// B, C, D, and E run in parallel</span></div><div class="line">A.broadcast(B, C, D, E);</div></div><!-- fragment --><h3>*gather*</h3>
<p>The method <code>gather</code> lets you add multiple precedences to a task.</p>
<div class="image">
<img src="image/gather.png" align="right" width="30%"/>
</div>
<div class="fragment"><div class="line"><span class="comment">// B, C, D, and E run in parallel</span></div><div class="line"><span class="comment">// A runs after B, C, D, and E complete</span></div><div class="line">A.gather(B, C, D, E);</div></div><!-- fragment --><h1>Caveats</h1>
<p>While Cpp-Taskflow enables the expression of very complex task dependency graph that might contain thousands of task nodes and links, there are a few amateur pitfalls and mistakes to be aware of.</p>
<ul>
<li>Having a cycle in a graph may result in running forever</li>
<li>Trying to modify a dispatched task can result in undefined behavior</li>
<li>Touching a taskflow from multiple threads are not safe</li>
</ul>
<p>Cpp-Taskflow is known to work on Linux distributions, MAC OSX, and Microsoft Visual Studio. Please <a href="#" onclick="location.href='mai'+'lto:'+'twh'+'76'+'081'+'2@'+'gma'+'il'+'.co'+'m'; return false;">let me know</a> if you found any issues in a particular platform.</p>
<h1>System Requirements</h1>
<p>To use Cpp-Taskflow, you only need a <a href="https://en.wikipedia.org/wiki/C%2B%2B17">C++17</a> compiler:</p><ul>
<li>GNU C++ Compiler v7.3 with -std=c++1z</li>
<li>Clang C++ Compiler v6.0 with -std=c++17</li>
<li>Microsoft Visual Studio Version 15.7 (MSVC++ 19.14)</li>
</ul>
<h1>Compile Unit Tests and Examples</h1>
<p>Cpp-Taskflow uses <a href="https://cmake.org/">CMake</a> to build examples and unit tests. We recommend using out-of-source build.</p>
<div class="fragment"><div class="line">~$ cmake --version  # must be at least 3.9 or higher</div><div class="line">~$ mkdir build</div><div class="line">~$ cd build</div><div class="line">~$ cmake ../</div><div class="line">~$ make </div></div><!-- fragment --><h2>Unit Tests</h2>
<p>Cpp-Taskflow uses <a href="https://github.com/onqtam/doctest">Doctest</a> for unit tests.</p>
<div class="fragment"><div class="line">~$ ./unittest/taskflow</div></div><!-- fragment --><p>Alternatively, you can use CMake's testing framework to run the unittest.</p>
<div class="fragment"><div class="line">~$ cd build</div><div class="line">~$ make test</div></div><!-- fragment --><h2>Examples</h2>
<p>The folder <code>example/</code> contains several examples and is a great place to learn to use Cpp-Taskflow.</p>
<table class="doxtable">
<tr>
<th>Example </th><th>Description  </th></tr>
<tr>
<td><a href="./example/simple.cpp">simple.cpp</a> </td><td>uses basic task building blocks to create a trivial taskflow graph </td></tr>
<tr>
<td><a href="./example/debug.cpp">debug.cpp</a></td><td>inspects a taskflow through the dump method </td></tr>
<tr>
<td><a href="./example/emplace.cpp">emplace.cpp</a></td><td>demonstrates the difference between the emplace method and the silent_emplace method </td></tr>
<tr>
<td><a href="./example/matrix.cpp">matrix.cpp</a> </td><td>creates two set of matrices and multiply each individually in parallel </td></tr>
<tr>
<td><a href="./example/dispatch.cpp">dispatch.cpp</a> </td><td>demonstrates how to dispatch a task dependency graph and assign a callback to execute </td></tr>
<tr>
<td><a href="./example/multiple_dispatch.cpp">multiple_dispatch.cpp</a> </td><td>illustrates dispatching multiple taskflow graphs as independent batches (which all run on the same threadpool) </td></tr>
<tr>
<td><a href="./example/parallel_for.cpp">parallel_for.cpp</a></td><td>parallelizes a for loop with unbalanced workload </td></tr>
<tr>
<td><a href="./example/reduce.cpp">reduce.cpp</a></td><td>performs reduce operations over linear containers </td></tr>
<tr>
<td><a href="./example/subflow.cpp">subflow.cpp</a></td><td>demonstrates how to create a subflow graph that spawns three dynamic tasks </td></tr>
<tr>
<td><a href="./example/threadpool.cpp">threadpool.cpp</a></td><td>benchmarks different threadpool implementations </td></tr>
<tr>
<td><a href="./example/threadpool_cxx14.cpp">threadpool_cxx14.cpp</a></td><td>shows use of the C++14-compatible threadpool implementation, which may be used when you have no inter-task (taskflow) dependencies to express </td></tr>
<tr>
<td><a href="./example/taskflow.cpp">taskflow.cpp</a></td><td>benchmarks taskflow on different task dependency graphs </td></tr>
<tr>
<td><a href="./example/executor.cpp">executor.cpp</a></td><td>shows how to create multiple taskflow objects sharing one executor to avoid the thread over-subscription problem </td></tr>
</table>
<h1>Get Involved</h1>
<ul>
<li>Report bugs/issues by submitting a <a href="https://github.com/cpp-taskflow/cpp-taskflow/issues">GitHub issue</a></li>
<li>Submit contributions using <a href="https://github.com/cpp-taskflow/cpp-taskflow/pulls">pull requests</a></li>
<li>Learn more about Cpp-Taskflow by reading the ./doc/home.md "documentation"</li>
<li>Find a solution to your question at ./doc/faq.md "Frequently Asked Questions"</li>
</ul>
<h1>Who is Using Cpp-Taskflow?</h1>
<p>Cpp-Taskflow is being used in both industry and academic projects to scale up existing workloads that incorporate complex task dependencies.</p>
<ul>
<li><a href="https://github.com/OpenTimer/OpenTimer">OpenTimer</a>: A High-performance Timing Analysis Tool for Very Large Scale Integration (VLSI) Systems</li>
<li><a href="http://dtcraft.web.engr.illinois.edu/">DtCraft</a>: A General-purpose Distributed Programming Systems using Data-parallel Streams</li>
<li><a href="https://github.com/ForgeMistress/Firestorm">Firestorm</a>: Fighting Game Engine with Asynchronous Resource Loaders (developed by <a href="https://github.com/ForgeMistress">ForgeMistress</a>)</li>
<li><a href="https://shiva.gitbook.io/project/shiva">Shiva</a>: An extensible engine via an entity component system through scripts, DLLs, and header-only (C++)</li>
</ul>
<p>Please <a href="#" onclick="location.href='mai'+'lto:'+'twh'+'76'+'081'+'2@'+'gma'+'il'+'.co'+'m'; return false;">let me know</a> if I forgot your project!</p>
<h1>Contributors</h1>
<p>Cpp-Taskflow is being actively developed and contributed by the following people:</p>
<ul>
<li><a href="https://twhuang.ece.illinois.edu/">Tsung-Wei Huang</a> created the Cpp-Taskflow project and implemented the core routines</li>
<li><a href="https://github.com/clin99">Chun-Xun Lin</a> co-created the Cpp-Taskflow project and implemented the core routines</li>
<li><a href="https://ece.illinois.edu/directory/profile/mdfwong">Martin Wong</a> supported the Cpp-Taskflow project through NSF and DARPA funding</li>
<li><a href="https://github.com/aolofsson">Andreas Olofsson</a> supported the Cpp-Taskflow project through the DARPA IDEA project</li>
<li><a href="https://github.com/NanXiao">Nan Xiao</a> fixed compilation error of unittest on the Arch platform</li>
<li><a href="https://github.com/innermous">Vladyslav</a> fixed comment errors in <a class="el" href="README_8md.html">README.md</a> and examples</li>
<li><a href="https://github.com/vblanco20-1">vblanco20-1</a> fixed compilation error on Microsoft Visual Studio</li>
<li><a href="https://github.com/totalgee">Glen Fraser</a> created a standalone C++14-compatible <a href="./taskflow/threadpool/threadpool_cxx14.hpp">threadpool</a> for taskflow; various other fixes and examples</li>
<li><a href="https://github.com/gguo4">Guannan Guo</a> added different threadpool implementations to enhance the performance for taskflow</li>
<li><a href="https://github.com/patrikhuber">Patrik Huber</a> helped fixed typos in the documentation</li>
<li><a href="https://github.com/ForgeMistress">ForgeMistress</a> provided API ideas about sharing the executor to avoid thread over-subscriptiong issues</li>
<li><a href="https://github.com/Neumann-A">Alexander Neumann</a> helped modify the cmake build to make Cpp-Taskflow importable from external cmake projects</li>
</ul>
<p>Meanwhile, we appreciate the support from many organizations for our development on Cpp-Taskflow. Please <a href="#" onclick="location.href='mai'+'lto:'+'twh'+'76'+'081'+'2@'+'gma'+'il'+'.co'+'m'; return false;">let me know</a> if I forgot someone!</p>
<p>| <a href="https://illinois.edu/"></a> | <a href="https://csl.illinois.edu/"></a> | <a href="https://www.nsf.gov/"></a> | <a href="https://www.darpa.mil/news-events/2017-09-13"></a> | | :&mdash;: | :&mdash;: | :&mdash;: | :&mdash;: |</p>
<h1>License</h1>
<p>Cpp-Taskflow is licensed under the <a href="./LICENSE">MIT License</a>.</p>
<hr/>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
